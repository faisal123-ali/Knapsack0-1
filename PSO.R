
item=c('Sofas ','couches','Bookshelves','armchairs','Desks','Dressers','wardrobes','Entertainment centers','Dinning Tables','Beds ')
weights = c(70,73,77,80,82,87,90,94,98,106)
values = c(135,139,149,150,156,163,173,184,192,201) 
data=data.frame(item,weights,values)
max_weight=750

#Define the PSO parameters
n_particles <- 200 # Number of particles
n_iterations <- 30 # Number of iterations
w <- 0.8 # Inertia weight
c1 <- 1 # Cognitive parameter
c2 <- 2 # Social parameter

#Define the fitness function
fitness <- function(x) {
  
  #Calculate the total weight and value of the knapsack
  total_weight <- sum(weights * x)
  total_value <- sum(values * x)
  
  #Penalize solutions that exceed the maximum weight capacity
  if (total_weight > max_weight) {
    return(0)
  }
  
  #Return the total value of the knapsack
  return(total_value)
}

#Initialize the particles
particles <- matrix(data = sample(c(0, 1), n_particles * length(weights), replace = TRUE), ncol = length(weights))
pbest <- particles
pbest_fitness <- apply(particles, 1, fitness)
gbest <- particles[which.max(pbest_fitness), ]
gbest_fitness <- max(pbest_fitness)

#Create a vector to store the best fitness values found so far
best_fitness <- numeric(n_iterations)
best_fitness1 <- numeric(n_iterations)

#Perform PSO
x=0
while (x!=30) {
  x=x+1
  
  print(x)
  for (i in 1:n_iterations) {
    
    #Update the velocity and position of each particle
    for (j in 1:n_particles) {
      # Calculate the velocity update
      velocity <- w * particles[j, ] +
        c1 * runif(length(weights)) * (pbest[j, ] - particles[j, ]) +
        c2 * runif(length(weights)) * (gbest - particles[j, ])
      
      # Update the position
      particles[j, ] <- ifelse(runif(length(weights)) < plogis(velocity), 1, 0)
      
      # Update the personal best
      fitness_j <- fitness(particles[j, ])
      if (fitness_j > pbest_fitness[j]) {
        pbest[j, ] <- particles[j, ]
        pbest_fitness[j] <- fitness_j
      }
      
      # Update the global best
      if (fitness_j > gbest_fitness) {
        gbest <- particles[j, ]
        gbest_fitness <- fitness_j
      }
    }
    
    #Store the best fitness value found so far
    best_fitness[i] <- gbest_fitness
    
    #Print the best solution so far
    cat("Iteration", i, "- Best fitness:", gbest_fitness, "- Best solution:", gbest, "\n")
  }
}

#The plot generated by the code is a line plot or a time series plot, which shows the progress of the PSO algorithm over time (number of iterations) in terms of the best fitness value found so far.

#Plot the results
plot(1:n_iterations, best_fitness, type = "l", xlab = "Generation",col="red", ylab = "Best Fitness")


#Define the population sizes to compare
pop_sizes <- c(20, 50, 200)

#Create a data frame to store the results
results <- data.frame(iteration = 1:n_iterations)

#Perform PSO for each population size and store the results
for (i in 1:length(pop_sizes)) {
  #Define the PSO parameters
  n_particles <- pop_sizes[i]
  n_iterations <- 30 # Number of iterations
  w <- 0.8 # Inertia weight
  c1 <- 1 # Cognitive parameter
  c2 <- 2 # Social parameter
  
  #Initialize the particles
  particles <- matrix(data = sample(c(0, 1), n_particles * length(weights), replace = TRUE), ncol = length(weights))
  pbest <- particles
  pbest_fitness <- apply(particles, 1, fitness)
  gbest <- particles[which.max(pbest_fitness), ]
  gbest_fitness <- max(pbest_fitness)
  
  #Create a vector to store the best fitness values found so far
  best_fitness <- numeric(n_iterations)
  
  #Perform PSO
  for (j in 1:n_iterations) {
    
    #Update the velocity and position of each particle
    for (k in 1:n_particles) {
      # Calculate the velocity update
      velocity <- w * particles[k, ] +
        c1 * runif(length(weights)) * (pbest[k, ] - particles[k, ]) +
        c2 * runif(length(weights)) * (gbest - particles[k, ])
      
      # Update the position
      particles[k, ] <- ifelse(runif(length(weights)) < plogis(velocity), 1, 0)
      
      # Update the personal best
      fitness_k <- fitness(particles[k, ])
      if (fitness_k > pbest_fitness[k]) {
        pbest[k, ] <- particles[k, ]
        pbest_fitness[k] <- fitness_k
      }
      
      # Update the global best
      if (fitness_k > gbest_fitness) {
        gbest <- particles[k, ]
        gbest_fitness <- fitness_k
      }
    }
    
    #Store the best fitness value found so far
    best_fitness[j] <- gbest_fitness
  }
  
  #Add the results to the data frame
  results[paste0("pop_", pop_sizes[i])] <- best_fitness
}

#Plot the results
plot(results$iteration, results$pop_20, type = "l", xlab = "Generation", ylab = "Best Fitness", col = "red", lwd = 2)
lines(results$iteration, results$pop_50, col = "green", lwd = 2)
lines(results$iteration, results$pop_200, col = "blue", lwd = 2)
legend("topright", legend = c("Population size 20", "Population size 50", "Population size 200"), col = c("red", "blue", "green"), lwd = 2)

